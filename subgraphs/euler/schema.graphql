type Account @entity(immutable: true) {
  id: Bytes!
  subAccount: Bytes!
  owner: Bytes!
}

type ProxyCreated @entity(immutable: true) {
  id: Bytes!
  proxy: Bytes! # address
  upgradeable: Boolean! # bool
  implementation: Bytes! # address
  trailingData: Bytes! # bytes
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerVault @entity(immutable: false) {
  id: Bytes!
  evc: Bytes!
  name: String!
  decimals: BigInt!
  borrowCap: BigInt!
  supplyCap: BigInt!
  dToken: Bytes!
  evault: Bytes!
  permit2Address: Bytes!
  perspectives:[String!]
  interestRateModel: Bytes!
  collaterals: [Bytes!]
  governonAdmin: Bytes!
  feeReceiver: Bytes!
  asset: Bytes
  oracle: Bytes!
  creator: Bytes!
  symbol: String!
  unitOfAccount: Bytes!
  state: VaultStatus 
  interestFee: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type BalanceForwarderStatus @entity(immutable: true) {
  id: Bytes!
  vault: Bytes! # address
  account: Bytes! # address
  status: Boolean! # bool
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Borrow @entity(immutable: true) {
  id: Bytes!
  account: Bytes! # address
  assets: BigInt! # uint256
  vault: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ConvertFee @entity(immutable: true) {
  id: Bytes!
  vault: Bytes! # address  
  sender: Bytes! # address
  protocolReceiver: Bytes! # address
  governorReceiver: Bytes! # address
  protocolShares: BigInt! # uint256
  governorShares: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type DebtSocialized @entity(immutable: true) {
  id: Bytes!
  vault: Bytes! # address
  account: Bytes! # address
  assets: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Deposit @entity(immutable: true) {
  id: Bytes!
  sender: Bytes! # address
  owner: Bytes! # address
  assets: BigInt! # uint256
  shares: BigInt! # uint256
  vault: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EVaultCreated @entity(immutable: true) {
  id: Bytes!
  evault: Bytes! # address
  creator: Bytes! # address
  asset: Bytes! # address
  dToken: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type InterestAccrued @entity(immutable: true) {
  id: Bytes!
  vault: Bytes! # address
  account: Bytes! # address
  assets: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Liquidate @entity(immutable: true) {
  id: Bytes!
  vault: Bytes! # address
  liquidator: Bytes! # address
  violator: Bytes! # address
  collateral: Bytes! # address
  repayAssets: BigInt! # uint256
  yieldBalance: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type PullDebt @entity(immutable: true) {
  id: Bytes!
  vault: Bytes! # address
  from: Bytes! # address
  to: Bytes! # address
  assets: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Repay @entity(immutable: true) {
  id: Bytes!
  account: Bytes! # address
  assets: BigInt! # uint256
  vault: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Transfer @entity(immutable: true) {
  id: Bytes!
  from: Bytes! # address
  to: Bytes! # address
  value: BigInt! # uint256
  vault: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type VaultStatus @entity(immutable: true) {
  id: Bytes!
  vault: Bytes! #address
  totalShares: BigInt! # uint256
  totalBorrows: BigInt! # uint256
  accumulatedFees: BigInt! # uint256
  cash: BigInt! # uint256
  interestAccumulator: BigInt! # uint256
  interestRate: BigInt! # uint256
  supplyApy: BigInt!
  borrowApy: BigInt!
  timestamp: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Withdraw @entity(immutable: true) {
  id: Bytes!
  sender: Bytes! # address
  receiver: Bytes! # address
  owner: Bytes! # address
  assets: BigInt! # uint256
  shares: BigInt! # uint256
  vault: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

 
type Counter @entity(immutable: false) {
  id: Bytes! # bytes32
  type: String! # string
  value: BigInt! # uint256
  blockNumber: BigInt
  blockTimestamp: BigInt
  transactionHash: Bytes
  isGlobal: Boolean!
}

type AccountAggrVault @entity(immutable: true) {
  id: Bytes!
  accountPrefix: Bytes!
  vaults: [VaultByAccount!]! @derivedFrom(field: "account")
}

type VaultByAccount @entity(immutable: true) {
  id: Bytes!
  account: AccountAggrVault!
  vault: Bytes!
}


########################################################
# Tracking
########################################################

type CallWithContext @entity(immutable: true) {
  id: Bytes! # txHash + vaultAddress
  selector: String!
  vault: Bytes!
  mainAddress: Bytes!
  accounts: [Bytes!]!
  type: String!
  evc: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}


type TrackingActiveAccount @entity(immutable: false) {
  id: Bytes! # mainAddress 
  mainAddress: Bytes!
  deposits: [Bytes!]!  # account + vault
  borrows: [Bytes!]!  # account + vault
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type TrackingVaultBalance @entity(immutable: false) {
  id: Bytes!  # account + vault
  isControllerEnabled: Boolean!
  vault: Bytes!
  mainAddress: Bytes!
  account: Bytes!
  balance: BigInt!
  debt: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}


########################################################
# Earn
########################################################

type DeployEulerEarn @entity(immutable: true) {
  id: Bytes!
  owner: Bytes! # address
  eulerEarnVault: Bytes! # address
  asset: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnApproval @entity(immutable: true) {
  id: Bytes!
  owner: Bytes! # address
  spender: Bytes! # address
  value: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}


type EulerEarnDeposit @entity(immutable: true) {
  id: Bytes!
  sender: Bytes! # address
  owner: Bytes! # address
  assets: BigInt! # uint256
  shares: BigInt! # uint256
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnTransfer @entity(immutable: true) {
  id: Bytes!
  from: Bytes! # address
  to: Bytes! # address
  value: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnWithdraw @entity(immutable: true) {
  id: Bytes!
  sender: Bytes! # address
  receiver: Bytes! # address
  owner: Bytes! # address
  assets: BigInt! # uint256
  shares: BigInt! # uint256
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnAccrueInterest @entity(immutable: true) {
  id: Bytes!
  newTotalAssets: BigInt! # uint256
  feeShares: BigInt! # uint256
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnOwnershipTransferStarted @entity(immutable: true) {
  id: Bytes!
  previousOwner: Bytes! # address
  newOwner: Bytes! # address
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnOwnershipTransferred @entity(immutable: true) {
  id: Bytes!
  previousOwner: Bytes! # address
  newOwner: Bytes! # address
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnRevokePendingCap @entity(immutable: true) {
  id: Bytes!
  caller: Bytes! # address
  market: Bytes! # address
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnRevokePendingGuardian @entity(immutable: true) {
  id: Bytes!
  caller: Bytes! # address
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnRevokePendingMarketRemoval @entity(immutable: true) {
  id: Bytes!
  caller: Bytes! # address
  market: Bytes! # address
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnRevokePendingTimelock @entity(immutable: true) {
  id: Bytes!
  caller: Bytes! # address
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnSetCap @entity(immutable: true) {
  id: Bytes!
  caller: Bytes! # address
  market: Bytes! # address
  cap: BigInt! # uint256
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnSetCurator @entity(immutable: true) {
  id: Bytes!
  newCurator: Bytes! # address
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnSetFee @entity(immutable: true) {
  id: Bytes!
  caller: Bytes! # address
  fee: BigInt! # uint256
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnSetFeeRecipient @entity(immutable: true) {
  id: Bytes!
  newFeeRecipient: Bytes! # address
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnSetGuardian @entity(immutable: true) {
  id: Bytes!
  caller: Bytes! # address
  guardian: Bytes! # address
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnSetIsAllocator @entity(immutable: true) {
  id: Bytes!
  allocator: Bytes! # address
  isAllocator: Boolean! # bool
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnSetName @entity(immutable: true) {
  id: Bytes!
  name: String! # string
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnSetSupplyQueue @entity(immutable: true) {
  id: Bytes!
  caller: Bytes! # address
  supplyQueue: [Bytes!]! # address[]
  vault: Bytes!  
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnSetSymbol @entity(immutable: true) {
  id: Bytes!
  symbol: String! # string
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnSetTimelock @entity(immutable: true) {
  id: Bytes!
  caller: Bytes! # address
  vault: Bytes!
  timelock: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnSetWithdrawQueue @entity(immutable: true) {
  id: Bytes!
  caller: Bytes! # address
  withdrawQueue: [Bytes!]! # address[]
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnSubmitCap @entity(immutable: true) {
  id: Bytes!
  caller: Bytes! # address
  market: Bytes! # address
  cap: BigInt! # uint256
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnSubmitGuardian @entity(immutable: true) {
  id: Bytes!
  newGuardian: Bytes! # address
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnSubmitMarketRemoval @entity(immutable: true) {
  id: Bytes!
  caller: Bytes! # address
  market: Bytes! # address
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnSubmitTimelock @entity(immutable: true) {
  id: Bytes!
  timelock: BigInt! # uint256
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnReallocateSupply @entity(immutable: true) {
  id: Bytes!
  caller: Bytes! # address - the caller parameter
  market: Bytes! # address - the id parameter (mapping id to market for semantics)
  suppliedAssets: BigInt! # uint256
  suppliedShares: BigInt! # uint256
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnReallocateWithdraw @entity(immutable: true) {
  id: Bytes!
  caller: Bytes! # address - the caller parameter
  market: Bytes! # address - the id parameter (mapping id to market for semantics)
  withdrawnAssets: BigInt! # uint256
  withdrawnShares: BigInt! # uint256
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnUpdateLastTotalAssets @entity(immutable: true) {
  id: Bytes!
  updatedTotalAssets: BigInt! # uint256
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerEarnUpdateLostAssets @entity(immutable: true) {
  id: Bytes!
  newLostAssets: BigInt! # uint256
  vault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}
 
type Strategy @entity(immutable: false){
  id: Bytes!
  strategy: Bytes!
  allocatedAssets: BigInt!
  availableAssets: BigInt!
  currentAllocationCap: BigInt!
  pendingAllocationCap: BigInt!
  pendingAllocationCapValidAt: BigInt!
  removableAt: BigInt!
  eulerVault: EulerVault!
}

type EulerEarnVault @entity(immutable: false) {
    id: Bytes!
    evc: Bytes!
    name: String!
    symbol: String!
    performanceFee: BigInt!
    asset: Bytes! 
    
    # USERS
    owner: Bytes!
    creator: Bytes!
    curator: Bytes!
    guardian: Bytes!
    feeReceiver: Bytes!
    # Timelocks
    timelock: BigInt!
    pendingTimelock: BigInt!
    pendingTimelockValidAt: BigInt!
    pendingGuardian: Bytes!
    pendingGuardianValidAt: BigInt!
    # LISTS
    supplyQueue: [Bytes!]
    strategies: [Strategy!]
    
    perspectives: [String!]
     
    # totals
    totalShares: BigInt!
    totalAssets: BigInt!
    totalLostAssets: BigInt!
    totalAllocated: BigInt!
    totalSupply: BigInt!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    transactionHash: Bytes!
}



########################################################
# Euler Swap
########################################################

## FACTORY 

type EulerSwapPool @entity(immutable: false) {
  id: Bytes!
  asset0: Bytes! 
  asset1: Bytes!
  vault0: Bytes
  vault1: Bytes
  fee: BigInt
  protocolFee: BigInt
  protocolFeeRecipient: Bytes
  eulerAccount: Bytes!
  equilibriumReserve0: BigInt
  equilibriumReserve1: BigInt
  currReserve0: BigInt
  currReserve1: BigInt
  priceY: BigInt
  priceX: BigInt
  concentrationX: BigInt
  concentrationY: BigInt
  pool: Bytes!
  active: Boolean!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerSwapPoolUninstalled @entity(immutable: true) {
  id: Bytes!
  asset0: Bytes! 
  asset1: Bytes!
  eulerAccount: Bytes!
  pool: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

## PoolUninstalled

type EulerSwapActivated  @entity(immutable: true) {
  id: Bytes!
  asset0: Bytes! 
  asset1: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EulerSwap  @entity(immutable: true) {
  id: Bytes!
  sender: Bytes! 
  amount0In: BigInt!
  amount1In: BigInt!
  amount0Out: BigInt!
  amount1Out: BigInt!
  reserve0: BigInt!
  reserve1: BigInt!
  fee: BigInt
  protocolFee: BigInt
  from: Bytes!
  to: Bytes!
  pool: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Perspective @entity(immutable: false){
  id: String!
  name: String!
  address: Bytes!
  perspectiveType: String!
  verifiedVaults: [Bytes!]
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

